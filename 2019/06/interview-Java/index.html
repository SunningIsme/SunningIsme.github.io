<!DOCTYPE html>
<html lang="zh-CN">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <!--Description-->
  
  <meta name="description" content="爆炸头网，分享Web开发中的技术文章，分享生活中的灵感与创意，鼓励阅读，不读书则愚。">
  

  <!--Author-->
  
  <meta name="author" content="Ning Sun">
  

  <!--Open Graph Title-->
  
      <meta property="og:title" content="Java之面试备战">
  
  <!--Open Graph Description-->
  
      <meta property="og:description" content="爆炸头网，分享Web开发中的技术文章，分享生活中的灵感与创意，鼓励阅读，不读书则愚。">
  
  <!--Open Graph Site Name-->
  <meta property="og:site_name" content="爆炸头博客">
  <!--Type page-->
  
      <meta property="og:type" content="article">
  
  <!--Page Cover-->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- Title -->
  
  <title>Java之面试备战 - 爆炸头博客</title>


  <link rel="shortcut icon" href="https://hexo.io/icon/favicon-96x96.png">

  <!-- Custom CSS/Sass -->
  <link rel="stylesheet" href="/css/style.css">

  <!----------------------------
  https://github.com/GallenHu/hexo-theme-Daily

 _____            _   _
|  __ \          (_) | |
| |  | |   __ _   _  | |  _   _
| |  | |  / _` | | | | | | | | |
| |__| | | (_| | | | | | | |_| |
|_____/   \__,_| |_| |_|  \__, |
                          __/ |
                         |___/

    --------------------------->

</head>


<body>

  <!-- Nav -->
  <header class="site-header">
  <div class="header-inside">
    <div class="logo">
      <a href="/" rel="home">
        
        <img src="https://static.hinpc.com/images/2018/logo.svg" alt="爆炸头博客" height="60">
        
      </a>
    </div>
    <!-- Navigation -->
    <nav class="navbar">
      <!-- Collect the nav links, forms, and other content for toggling -->
      <div class="collapse">
        <ul class="navbar-nav">
          
          
            <li>
              <a href="/.">
                
                  Home
                
              </a>
            </li>
          
            <li>
              <a href="/archives">
                
                  Archive
                
              </a>
            </li>
          
            <li>
              <a href="/about">
                
                  About
                
              </a>
            </li>
          
        </ul>
      </div>
      <!-- /.navbar-collapse -->
    </nav>
    <div class="button-wrap">
      <button class="menu-toggle">Primary Menu</button>
    </div>
  </div>
</header>


  <!-- Main Content -->
  <div class="content-area">
  <div class="post">
    <!-- Post Content -->
    <div class="container">
      <article>
        <!-- Title date & tags -->
        <div class="post-header">
          <h1 class="entry-title">
            Java之面试备战
            
          </h1>
          <p class="posted-on">
          2019-06-16
          </p>
          <div class="tags-links">
            
              
                <a href="/tags/JVM/" rel="tag">
                  JVM
                </a>
              
                <a href="/tags/GC/" rel="tag">
                  GC
                </a>
              
            
          </div>
        </div>
        <!-- Post Main Content -->
        <div class="entry-content ">
          <p>备战面试</p>
<a id="more"></a>
<p>##1.谈谈你对java的理解<br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190618215754.png" alt></p>
<h3 id="1-1平台无关性"><a href="#1-1平台无关性" class="headerlink" title="1.1平台无关性"></a>1.1平台无关性</h3><p>javap -c 反编译 .class文件 要不然看到的是乱码<br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190618215943.png" alt><br>为什么JVM不直接将源码解析成机器码去执行？<br>因为如果解析成机器码去执行，每次执行前都会做很多检查，而且 其他语言也可以转化为字节码然后在JVM上运行<br>JVM是如何加载.class文件的？<br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190618220253.png" alt></p>
<h3 id="1-2反射"><a href="#1-2反射" class="headerlink" title="1.2反射"></a>1.2反射</h3><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种冬天获取信息以及动态调用对象功能称为java语言的反射机制<br>我觉得就是把类的所有属性和方法都反射刀对象上。<br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190618220612.png" alt><br>这个地方getDeclaredMethod方法获取所有方法 但是不能获取到继承的方法<br>而getMethod只能获取当前类的public方法但是可以获取到继承的方法<br>java反射就是把所有的java类的各种成分映射成一个个对象(比如方法对象，变量对象)</p>
<h3 id="1-3ClassLoader"><a href="#1-3ClassLoader" class="headerlink" title="1.3ClassLoader"></a>1.3ClassLoader</h3><p>ClassLoader在java中有非常重要的作用，它主要工作在Class装载的加载阶段，其主要作用是从系统外部获取Class二进制数据流。它是java的狠核心组件，所有的class都是由ClassLoader进行加载的，ClassLoader负责通过将Class文件里的二进制数据流装载进系统，然后交给Java虚拟机进行连接，初始化操作。</p>
<h3 id="1-4-类的加载方式"><a href="#1-4-类的加载方式" class="headerlink" title="1.4 类的加载方式"></a>1.4 类的加载方式</h3><p>隐式加载:new<br>显示加载:LoadClass,forName等<br>loadClass和forName的区别？<br>Class.forName得到的class是已经初始化完成的<br>Classloder.loadClass得到的class是还没有链接的<br>CLASS.FORNAME会先运行静态代码块，比如 加载mysql 的jar包就需要 forname<br>loadclass的 速率很快 比如 springioc中的依赖注入</p>
<h3 id="1-5-JVM内存模型"><a href="#1-5-JVM内存模型" class="headerlink" title="1.5 JVM内存模型"></a>1.5 JVM内存模型</h3><p><img src="http://pr6tkgeuu.bkt.clouddn.com//20190619075612.png" alt><br>程序计数器:<br>当前进程所执行的字节码行号指示器<br>改变计数器的值来选区下一条需要执行的字节码指令<br>和线程是一对一的关系即”线程私有”<br>对java方法计数，如果是Native方法则计数器值为Undefined<br>不会发生内存泄漏<br>java虚拟机栈:<br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190619075927.png" alt><br>每一个方法就是一个栈帧<br>局部变量表和操作数栈:<br>局部变量表:包含方法执行过程中的所有变量<br>操作数栈:入栈，出栈，复制，交换，产生消费变量<br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190619080242.png" alt></p>
<h3 id="1-6递归为什么会引发java-lang-StatckOverflowError异常"><a href="#1-6递归为什么会引发java-lang-StatckOverflowError异常" class="headerlink" title="1.6递归为什么会引发java.lang.StatckOverflowError异常"></a>1.6递归为什么会引发java.lang.StatckOverflowError异常</h3><p>因为每一次递归都会产生一个栈帧，然后虚拟机栈深度是有限的，如果递归次数太多每次的栈帧都没有得到释放，所以会堆积然后就会满了</p>
<h3 id="1-7虚拟机栈会引发java-lang-OutOfMemoryError异常"><a href="#1-7虚拟机栈会引发java-lang-OutOfMemoryError异常" class="headerlink" title="1.7虚拟机栈会引发java.lang.OutOfMemoryError异常"></a>1.7虚拟机栈会引发java.lang.OutOfMemoryError异常</h3><p><img src="http://pr6tkgeuu.bkt.clouddn.com//20190619081143.png" alt></p>
<h3 id="1-8-本地方法栈"><a href="#1-8-本地方法栈" class="headerlink" title="1.8 本地方法栈"></a>1.8 本地方法栈</h3><p>与虚拟机相似，主要作用于标注了native的方法<br>native方法:一个Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C＋＋中，你可以用extern “C”告知C＋＋编译器去调用一个C的函数</p>
<h3 id="1-9元空间与永久代的区别"><a href="#1-9元空间与永久代的区别" class="headerlink" title="1.9元空间与永久代的区别"></a>1.9元空间与永久代的区别</h3><p>元空间使用本地内存，而永久代使用的是jvm的内存<br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190619082334.png" alt></p>
<h3 id="2-0java堆"><a href="#2-0java堆" class="headerlink" title="2.0java堆"></a>2.0java堆</h3><p><img src="http://pr6tkgeuu.bkt.clouddn.com//20190619082527.png" alt></p>
<h3 id="2-1JVM三大调优参数"><a href="#2-1JVM三大调优参数" class="headerlink" title="2.1JVM三大调优参数"></a>2.1JVM三大调优参数</h3><p><img src="http://pr6tkgeuu.bkt.clouddn.com//20190619082903.png" alt><br>如果超过了初始值，则自动扩容到堆能达到的最大值大小</p>
<h3 id="2-2内存分配策略"><a href="#2-2内存分配策略" class="headerlink" title="2.2内存分配策略"></a>2.2内存分配策略</h3><p><img src="http://pr6tkgeuu.bkt.clouddn.com//20190619083349.png" alt></p>
<h3 id="2-3java内存模型中堆和栈的区别"><a href="#2-3java内存模型中堆和栈的区别" class="headerlink" title="2.3java内存模型中堆和栈的区别"></a>2.3java内存模型中堆和栈的区别</h3><p><img src="http://pr6tkgeuu.bkt.clouddn.com//20190619083631.png" alt><br>管理方式:栈自动释放，堆需要GC<br>空间大小：栈比堆小<br>碎片相关：栈产生的碎片远远小于堆<br>分配方式：栈支持静态分配和动态分配，而堆仅支持动态分配<br>效率：栈的效率比堆高<br>静态分配:是编译器完成的，比如局部变量的分配</p>
<h3 id="2-4intern方法"><a href="#2-4intern方法" class="headerlink" title="2.4intern方法"></a>2.4intern方法</h3><p><img src="http://pr6tkgeuu.bkt.clouddn.com//20190619084545.png" alt><br>这里”a”就代表了已经放入了常量池中，然后在new一个就在堆中也创建了个”a”<br>所以甭管怎么比较 两个地址肯定都是不一样的。因为intern仅限于string a = “a”;这种方式<br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190619090120.png" alt><br>jdk1.6以前只能放入副本进入<br>jdk1.7以后 把对象的引用也放入进去，我觉得意思就是把引用也只向他而已。而不是单纯的放个副本进去</p>
<h2 id="2-GC-垃圾回收机制"><a href="#2-GC-垃圾回收机制" class="headerlink" title="2. GC(垃圾回收机制)"></a>2. GC(垃圾回收机制)</h2><p>被判定为垃圾的标准:没有被其他对象引用<br>以前采用的判断是否为垃圾的算法:引用计数法<br>通过判断对象的引用数量来决定对象是否可以为回收<br>对每个实例都有一个引用计数器，被引用则+1，完成引用则-1<br>任何引用计数为0的对象实例可以被当作垃圾收集<br>优点：执行效率高，程序执行受影响小<br>缺点：无法检测出循环引用的情况，导致内存泄漏<br>当前判断是否为垃圾的算法：可达性算法<br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190620082712.png" alt><br>这里面有个关键点：GC Root对象<br>虚拟机栈中引用的对象(栈帧中的本地变量表)<br>方法区中的常量引用的对象<br>方法区中的类静态属性引用的对象<br>清除垃圾的算法：<br>1.标记-清除算法<br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190620083114.png" alt><br>标记：从根集合进行扫描，对存活的对象进行标记<br>清除：对内存从头到尾进行线性遍历，回收不可达对象内存<br>会导致碎片化<br>2.复制算法<br>分为对象面和空闲面<br>对象在对象面上创建<br>存活的对象被从对象面复制到空闲面<br>将对象面所有对象内存清除<br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190620083940.png" alt><br>3.标记-整理算法<br>标记：从根集合进行扫描，对存活的对象进行标记<br>清除：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收<br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190620084158.png" alt><br>4.jdk8以后版本分代收集算法<br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190620084748.png" alt><br>GC分类：<br>Minor GC:作用于年轻带<br>Full GC：作用于老年代<br>Minor GC:<br>年轻带：尽可能快速的收集掉那些生命周期短的对象<br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190620085037.png" alt><br> form区 和 to区一只在变的。<br> 每次移动 存活次数就会加1。如果达到15岁了就会被放到老年代<br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190620085221.png" alt><br>Full GC:<br>触发条件<br>老年代空间不足<br>永久代空间不足<br>CMS GC时出现promotion failed，concurrent mode failure<br>Minor GC晋升到老年代的平均大小大于老年代剩余空间<br>调用System.gc()<br>两个名词：<br>Stop-the-World<br>JVM由于要执行GC而停止了应用程序的执行(除了GC的线程，其他线程都会被停掉)<br>任何一种GC算法中都会发生<br>多数GC优化通过减少Stop-the-world发生的时间来提高性能<br>Safepoint<br>分析过程中对象引用关系不会发生变化的点<br>产生Safepoint的地方：方法调用，循环跳转，异常跳转等<br>安全点数量得适中</p>
<h3 id="2-1Object的finalize-方法的作用是否与C-的析构函数作用相同"><a href="#2-1Object的finalize-方法的作用是否与C-的析构函数作用相同" class="headerlink" title="2.1Object的finalize()方法的作用是否与C++的析构函数作用相同"></a>2.1Object的finalize()方法的作用是否与C++的析构函数作用相同</h3><p>与C++的析构函数不同，析构函数调用确定，而它的不确定(执行的时间点的不确定)<br>将未被引用的对象放置于F-Queue队列(如果被标记，则会判断是否内部含有finalize方法，如果没有的话会被放入队列，之后会被清除)<br>方法执行随时可能被终止(因为优先级特别低，随时可被终止)<br>给予对象最后一次重生机会(通过再次把本对象付给finalzie()方法中的对象)<br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190620091254.png" alt><br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190620091210.png" alt></p>
<h3 id="2-2四种引用的作用"><a href="#2-2四种引用的作用" class="headerlink" title="2.2四种引用的作用"></a>2.2四种引用的作用</h3><p><img src="http://pr6tkgeuu.bkt.clouddn.com//20190620091337.png" alt><br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190620091349.png" alt><br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190620091415.png" alt><br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190620091608.png" alt><br>作用:<br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190620091634.png" alt><br>我觉的这里的回收 限制于 内存不足的情况下和 正常GC情况下。<br>如果强引用的引用被清除了，该占有的堆空间也会被回收<br>引用队列:引用队列可以配合软引用，弱引用以及幽灵引用使用，当引用的对象将要被JVM回收时，会将其加入到引用队列中。(虚引用必须得使用队列，因为他因为很弱随时都会被回收。)</p>
<h2 id="1-String-StringBuffer-StringBuilder的区别"><a href="#1-String-StringBuffer-StringBuilder的区别" class="headerlink" title="1.String StringBuffer StringBuilder的区别"></a>1.String StringBuffer StringBuilder的区别</h2><p>String类是final类，也即意味着String类不能被继承，并且它的成员方法都默认为final方法。<br>对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象”。<br>String str1 = “hello world”是被存储到常量池的<br>String str2 = new String(“hello world”);整个是new出来的存放到堆里面<br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190622173711.png" alt><br>这段代码会被JVM解析成下面这段代码<br>StringBuilder str = new StringBuilder(string);<br>　　str.append(“hello”);<br>str.toString();<br>所以string中new出来的对象还是会无限创建 删除<br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190622173855.png" alt><br>String bb=”aa”+”bb”+”cc”+”dd”<br>实际上创建了一个对象，因为java虚拟机会在编译的时候将<br>加法表达式进行优化，自动编译成这些常量相加的结果，<br>相当于定义了一个”aabbccdd”的字符串，所以它只创建了一个对象<br><code>主要区别在于先声明后然后再增加数值还是声明的时候赋值并且进行增加操作</code><br>从这里可以明显看出，这段代码的for循环式从13行开始到27行结束，并且new操作只进行了一次，也就是说只生成了一个对象，append操作是在原有对象的基础上进行的。因此在循环了10000次之后，这段代码所占的资源要比上面小得多。<br>别是StringBuffer类的成员方法前面多了一个关键字：synchronized，不用多说，这个关键字是在多线程访问时起到安全保护作用的,也就是说StringBuffer是线程安全<br>1、在字符串不经常发生变化的业务场景优先使用String(代码更清晰简洁)。如常量的声明，少量的字符串操作(拼接，删除等)。<br>2、在单线程情况下，如有大量的字符串操作情况，应该使用StringBuilder来操作字符串。不能使用String”+”来拼接而是使用，避免产生大量无用的中间对象，耗费空间且执行效率低下（新建对象、回收对象花费大量时间）。如JSON的封装等。<br>3、在多线程情况下，如有大量的字符串操作情况，应该使用StringBuffer。如HTTP参数解析和封装等。</p>
<h2 id="2-Java异常"><a href="#2-Java异常" class="headerlink" title="2.Java异常"></a>2.Java异常</h2><p><img src="http://pr6tkgeuu.bkt.clouddn.com//20190622174632.png" alt><br>从概念角度解析java的异常处理机制<br>Error:程序无法处理的系统错误，编译器不做检查<br>Exception：程序可以处理的异常，捕获后可能恢复<br>总结：前者是程序无法处理的错误，后者是可以处理的异常<br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190622184240.png" alt><br>从责任角度看：<br>1.Error属于JVM需要担负的责任<br>2.RuntimeException是程序应该承担的责任<br>3.Check Exception可检查异常是Java编译器应该承担的责任。<br>常见的异常：<br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190622184525.png" alt><br>通常设计异常处理的过程<br>设计一个通用的继承自RuntimeException的异常来统一处理异常<br>其余异常都统一转译为上述异常AppException<br>在catch之后，抛出上述异常的子类，并提供足以定位的信息<br>由前端接受AppException做统一处理<br>try-catch处理方式<br>try-catch块影响JCM的优化<br>异常对象实例需要保存栈快照等信息，开销较大(包住的代码块尽量少而且精准)</p>
<h2 id="3-数据结构基本考点"><a href="#3-数据结构基本考点" class="headerlink" title="3.数据结构基本考点"></a>3.数据结构基本考点</h2><p>数组和链表的区别：<br>链表是链式的存储结构；数组是顺序的存储结构。<br>链表通过指针来连接元素与元素，数组则是把所有元素按次序依次存储。(数组是一块连续的区域)<br>链表的插入删除元素相对数组较为简单，不需要移动元素，且较为容易实现长度扩充，但是寻找某个元素较为困难；<br>数组寻找某个元素较为简单，但插入与删除比较复杂，由于最大长度需要再编程一开始时指定，故当达到最大长度时，扩充长度不如链表方便。<br>队列和栈的应用：<br>二叉树的遍历方式及其递归和非递归的实现<br>前序：跟左右<br>递归实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void pre_order(BTree *root)    </span><br><span class="line">&#123;    </span><br><span class="line">     if(root != NULL)//必不可少的条件,递归的出口    </span><br><span class="line">     &#123;    </span><br><span class="line">        printf(&quot;%2c&quot;,root-&gt;key);    //访问根结点</span><br><span class="line">        pre_order(root-&gt;lchild);     //前序遍历左子树 </span><br><span class="line">        pre_order(root-&gt;rchild);    //前序遍历右子树 </span><br><span class="line">  </span><br><span class="line">     &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>中序遍历：<br>左根右<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void in_order(BTree* root)    </span><br><span class="line">&#123;    </span><br><span class="line">    //必不可少的条件,递归的出口   </span><br><span class="line">     if(root != NULL)   </span><br><span class="line">     &#123;    </span><br><span class="line">        in_order(root-&gt;lchild);    </span><br><span class="line">        printf(&quot;%2c&quot;,root-&gt;data);    </span><br><span class="line">        in_order(root-&gt;rchild);      </span><br><span class="line">     &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>后序遍历:<br>左右根<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void post_order(BTree* root)    </span><br><span class="line">&#123;    </span><br><span class="line">    //必不可少的条件,递归的出口   </span><br><span class="line">    if(root != NULL)   </span><br><span class="line">    &#123;    </span><br><span class="line">        post_order(root-&gt;lchild);    </span><br><span class="line">        post_order(root-&gt;rchild);    </span><br><span class="line">        printf(&quot;%2c&quot;,root-&gt;data);    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-算法考点"><a href="#4-算法考点" class="headerlink" title="4.算法考点"></a>4.算法考点</h2><p>内部排序—<br>快速排序：<br>方法其实很简单：分别从初始序列“6  1  2 7  9  3  4  5 10  8”两端开始“探测”。先从右往左找一个小于6的数，再从左往右找一个大于6的数，然后交换他们。这里可以用两个变量i和j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵i”和“哨兵j”。刚开始的时候让哨兵i指向序列的最左边（即i=1），指向数字6。让哨兵j指向序列的最右边（即j=10），指向数字8<br>冒泡排序：<br>从数组头部开始，不断比较相邻的两个元素的大小，让较大的元素逐渐往后移动（交换两个元素的值），直到数组的末尾。经过第一轮的比较，就可以找到最大的元素，并将它移动到最后一个位置。第一轮结束后，继续第二轮。仍然从数组头部开始比较，让较大的元素逐渐往后移动，直到数组的倒数第二个元素为止。经过第二轮的比较，就可以找到次大的元素，并将它放到倒数第二个位置。<br>选择排序：<br>for循环进行比较，定义一个第三个变量temp，首先前两个数比较，把较小的数放在temp中，然后用temp再去跟剩下的数据比较，如果出现比temp小的数据，就用它代替temp中原有的数据<br>内部排序：待排序记录存放在计算机随机存储器中（说简单点，就是内存）进行的排序过程。<br>外部排序：待排序记录的数量很大，以致于内存不能一次容纳全部记录，所以在排序过程中需要对外存进行访问的排序过程。</p>
<h2 id="5-Collection集合类"><a href="#5-Collection集合类" class="headerlink" title="5.Collection集合类"></a>5.Collection集合类</h2><p><img src="http://pr6tkgeuu.bkt.clouddn.com//20190622213812.png" alt><br>HashMap<br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190622214155.png" alt><br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190622214830.png" alt><br>ConcurrentHashMap<br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190622214926.png" alt><br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190622215424.png" alt></p>
<h2 id="1-Spring-IOC"><a href="#1-Spring-IOC" class="headerlink" title="1.Spring IOC"></a>1.Spring IOC</h2><p><img src="http://pr6tkgeuu.bkt.clouddn.com//20190622215915.png" alt><br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190622215926.png" alt><br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190622220017.png" alt><br>依赖注入方式<br>Setter<br>Interface<br>Constructor<br>Annotation<br>IOC容器<br>避免在各处使用new来创建类，并且可以做到统一维护<br>创建实例的时候不需要了解其中的细节<br><img src="http://pr6tkgeuu.bkt.clouddn.com//20190622220836.png" alt><br>根据java的反射功能实例化bean<br>IOC支持的功能：<br>依赖注入<br>依赖检查<br>自动装配<br>支持集合<br>制定初始化方法和销毁方法<br>支持回调方法</p>

        </div>
      </article>
    </div>
    <!-- Comments -->
    <div class="container">
      
<section id="comment">
  <!-- <h1 class="title">留言</h1> -->

  
  <div id="disqus_thread">
    <script type="text/javascript">
    var disqus_config = function () {
          this.page.url = window.location.href;
          this.page.identifier = 'post-interview-Java';
          this.page.title = 'Java之面试备战';
      };
    </script>
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
  
</section>


    </div>
    <!-- Pre or Next -->
    <div class="nav-links">
      
        <div class="nav-previous">
          <a href="/2019/06/interview-database/" rel="prev"><span class="meta-arraw meta-arraw-left"></span> 上一页</a>
        </div>
      
      
        <div class="nav-next">
          <a href="/2019/06/jdk8-characteristic/" rel="prev">下一页 <span class="meta-arraw meta-arraw-right"></span></a>
        </div>
      
    </div>

  </div>
</div>


  <!-- Footer -->
  <!-- Footer-widgets -->
<div class="footer-widgets">
  <div class="row inside-wrapper">
    <div class="col-1-3">
      <aside>
        <h1 class="widget-title">关于本站</h1>
        <div class="custom-widget-content">
          
          <p align="left">分享Web开发中的技术文章，分享生活中的灵感与创意，鼓励阅读，不读书则愚。</p>
        </div>
      </aside>
    </div>
    <div class="col-1-3">
      <aside>
        <h1 class="widget-title">与我联系</h1>
        <div class="widget-text">
          
            
              <a href="https://github.com/SunningIsme" class="icon icon-github" target="_blank">github</a>
            
              <a href="https://twitter.com/GallenHu" class="icon icon-twitter" target="_blank">twitter</a>
            
              <a href="mailto:1239222923@qq.com" class="icon icon-mail" target="_blank">mail</a>
            
          
        </div>
      </aside>
    </div>
    <div class="col-1-3">
      <aside>
        <h1 class="widget-title">站内搜索</h1>
        <div class="widget-text">
          <form onsubmit="return appDaily.submitSearch('')">
            <p>
              <input type="text" placeholder="search..." id="homeSearchInput">
            </p>
            <!-- <input type="submit" value="GO"> -->
          </form>
        </div>
      </aside>
    </div>
  </div>
</div>
<!-- Footer -->
<footer class="site-info">
  <p>
    <span>爆炸头博客 &copy; 2019</span>
    
      <span class="split">|</span>
      <span>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> with Theme <a href="https://github.com/GallenHu/hexo-theme-Daily" target="_blank">Daily</a></span>
    
  </p>
</footer>


  <!-- After footer scripts -->
  <!-- scripts -->
<script src="/js/app.js"></script>

<script>
  var disqus_shortname = 'hinpc';

  
  var disqus_url = 'http://sunning123.top/2019/06/interview-Java/';
  

  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>





</body>

</html>
